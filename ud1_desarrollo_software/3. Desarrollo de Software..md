Entendemos por Desarrollo de Software:

>el proceso que ocurre desde que se concibe una idea hasta que un programa est谩 implementado en el ordenador y funcionando.

![[ciclo_desarrollo.png]]

El proceso de desarrollo, que en un principio puede parecer una tarea simple, consta de una serie de pasos de *obligado cumplimiento*, pues s贸lo as铆 puede garantizarse que los
programas creados son eficientes, fiables, seguros y responden a las necesidades de usuarios finales (aqu茅llos que van a utilizar el programa).

Etapas metodolog铆as cl谩sicas de desarrollo:
#### **1. An谩lisis**

Es la etapa en la que se identifican y comprenden **los requisitos** del sistema a desarrollar. Aqu铆 se responde a **qu茅 necesita el cliente o usuario final** y **qu茅 debe hacer el software**.  
Incluye:

- Recolecci贸n de requisitos.
    
- Estudio de viabilidad.
    
- An谩lisis funcional y no funcional.
    

 _Objetivo:_ Comprender el problema y establecer una base clara para el dise帽o.

---

#### **2. Dise帽o**

Consiste en definir **c贸mo se va a construir** el software. Se estructura la soluci贸n t茅cnica que cumple con los requisitos analizados.  
Se divide com煤nmente en:

- Dise帽o de arquitectura (estructuras, m贸dulos, interfaces).
    
- Dise帽o detallado (algoritmos, estructuras de datos, esquemas de base de datos).
    

 _Objetivo:_ Plasmar una soluci贸n t茅cnica bien definida, antes de programar.

---

#### **3. Codificaci贸n**

Es la etapa donde los dise帽adores y programadores **escriben el c贸digo fuente** en uno o varios lenguajes de programaci贸n.  
Se implementan los m贸dulos definidos en el dise帽o.

 _Objetivo:_ Transformar el dise帽o en software funcional.

---

#### **4. Pruebas**

El software desarrollado se **verifica y valida** para asegurarse de que cumple con los requisitos establecidos.  
Incluye:

- Pruebas unitarias (m贸dulos individuales).
    
- Pruebas de integraci贸n (conjuntos de m贸dulos).
    
- Pruebas del sistema (comportamiento general).
    
- Pruebas de aceptaci贸n (por parte del cliente o usuario).
    

И _Objetivo:_ Detectar y corregir errores antes de la entrega.

---

### **5. Documentaci贸n**

Consiste en crear y mantener **manuales t茅cnicos y de usuario** que expliquen c贸mo se ha construido y c贸mo se usa el software.  
Puede incluir:

- Manual de instalaci贸n.
    
- Gu铆a del usuario.
    
- Documentaci贸n t茅cnica del c贸digo.
    

 _Objetivo:_ Facilitar el uso, la comprensi贸n y la futura evoluci贸n del software.

---

#### **6. Explotaci贸n (Despliegue o implantaci贸n)**

Es el proceso de **poner el software en funcionamiento** en el entorno real de los usuarios finales.  
Incluye:

- Instalaci贸n.
    
- Configuraci贸n.
    
- Capacitaci贸n de usuarios.
    

 _Objetivo:_ Que el software empiece a ser utilizado productivamente.

---

#### **7. Mantenimiento**

Despu茅s del despliegue, se realiza el mantenimiento para **corregir errores, mejorar funcionalidades o adaptarse a cambios** (por ejemplo, en el entorno o nuevas necesidades del cliente).  
Tipos:

- Correctivo (errores).
    
- Perfectivo (mejoras).
    
- Adaptativo (cambios externos).
    

 _Objetivo:_ Mantener el software 煤til, seguro y actualizado en el tiempo.

---
Tabla resumen de las etapas cl谩sicas:

| **Etapa**            | **Descripci贸n**                                                          | **Objetivo Principal**                                |
| -------------------- | ------------------------------------------------------------------------ | ----------------------------------------------------- |
| **1. An谩lisis**      | Identificaci贸n y comprensi贸n de los requisitos del sistema.              | Qu茅 necesita el usuario y qu茅 debe hacer el software. |
| **2. Dise帽o**        | Planificaci贸n t茅cnica de la soluci贸n: arquitectura, m贸dulos, interfaces. | C贸mo se construir谩 el software.                       |
| **3. Codificaci贸n**  | Programaci贸n del sistema conforme al dise帽o t茅cnico.                     | Traducir el dise帽o en c贸digo funcional.               |
| **4. Pruebas**       | Verificaci贸n y validaci贸n del software para detectar y corregir errores. | Asegurar que el software funciona correctamente.      |
| **5. Documentaci贸n** | Creaci贸n de manuales t茅cnicos y de usuario.                              | Facilitar el uso y mantenimiento del sistema.         |
| **6. Explotaci贸n**   | Puesta en marcha del software en el entorno real.                        | Los usuarios pueden utilizar el software.             |
| **7. Mantenimiento** | Correcci贸n de errores, mejoras y adaptaci贸n a nuevos requisitos.         | Mantener el software 煤til, eficiente y actualizado.   |
Ya hemos visto que la serie de pasos a seguir para desarrollar un programa es lo que se conoce como **Ciclo de Vida del Software**.

Se han planteado distintos *modelos de ciclos de vida*, pero los m谩s conocidos y utilizados son:

####  1. **Modelo en Cascada (Waterfall)**

**Definici贸n:**  
Es un modelo **secuencial** donde el desarrollo avanza paso a paso (etapa por etapa), sin retroceder. Cada fase (an谩lisis, dise帽o, codificaci贸n, pruebas, etc.) debe completarse antes de pasar a la siguiente.

**Caracter铆sticas:**

- Proceso lineal.
    
- La documentaci贸n es clave.
    
- Poco flexible ante cambios.
    

**Ventajas:**

- Sencillo de planificar y gestionar.
    
- Adecuado cuando los requisitos est谩n bien definidos desde el inicio.
    

**Inconvenientes:**

- No se adapta bien a cambios posteriores.
    
- El producto final no se ve hasta las 煤ltimas fases.
    

**Cu谩ndo se usa:**  
Proyectos peque帽os o bien definidos desde el principio.

---

####  2. **Modelo en Cascada con Realimentaci贸n**

**Definici贸n:**  
Es una mejora del modelo en cascada tradicional que permite **retroalimentaci贸n** (volver a fases anteriores si se detectan errores o cambios).

**Caracter铆sticas:**

- A帽ade **flexibilidad** al proceso.
    
- Permite revisar decisiones pasadas si surgen problemas en etapas posteriores.
    

**Ventajas:**

- Mayor capacidad de correcci贸n.
    
- Reducci贸n de errores graves acumulados.
    

**Inconvenientes:**

- Aumenta el tiempo y coste si se retrocede frecuentemente.
    

**Cu谩ndo se usa:**  
Cuando el cliente puede cambiar de opini贸n o los requisitos no son del todo estables.

![[cascada_realimentado.png]]

---

####  3. **Modelo Evolutivo - Iterativo - Incremental**

**Definici贸n:**  
El software se desarrolla en **m煤ltiples versiones o incrementos**. Cada versi贸n a帽ade nuevas funcionalidades y se entrega al usuario para recibir retroalimentaci贸n.

**Caracter铆sticas:**

- Desarrollos **parciales y sucesivos**.
    
- **Iteraci贸n:** se repite el ciclo desarrollo-pruebas-mejoras.
    
- **Incremental:** cada entrega mejora la anterior.
    

**Ventajas:**

- Permite una entrega temprana de versiones 煤tiles.
    
- Se adapta bien a cambios durante el desarrollo.
    
- Implica al cliente en el proceso.
    

**Inconvenientes:**

- Puede requerir una buena gesti贸n de versiones.
    
- M谩s complejo de planificar.
    

**Cu谩ndo se usa:**  
Proyectos medianos o grandes con requisitos cambiantes o no del todo claros.

![[modelo_incremental.png]]

Interpretaci贸n del modelo iterativo incremental:

>La idea fundamental detr谩s de la mejora iterativa es desarrollar un sistema de software incrementalmente, permitiendo al desarrollador aprovechar lo que se va aprendiendo durante el desarrollo de las versiones tempranas, incrementales y entregables del sistema. 
>
>El aprendizaje viene tanto del desarrollo como del uso del sistema, donde sea posible. 
>
>Los pasos clave en el proceso consisten en empezar con una implementaci贸n sencilla de un subconjunto de los requisitos del software y mejorar iterativamente la evoluci贸n secuencial de versiones hasta que el sistema est谩 implementado.
>
>En cada iteraci贸n, se hacen modificaciones en el dise帽o a la misma vez que a帽adimos nuevas funcionalidades.

![[modelo_incremental_metafora.png]]
![[modelo_incremental_metafora2.png]]
Fuente https://blog.jmbeas.es/2019/09/22/desarrollo-iterativo-e-incremental/

---

####  4. **Modelo en Espiral**

**Definici贸n:**  
Combina caracter铆sticas del modelo iterativo con t茅cnicas de **gesti贸n de riesgos**. Se desarrolla en ciclos (espirales), y en cada uno se eval煤an los riesgos y se construye un prototipo.

**Caracter铆sticas:**

- Cada espiral incluye: planificaci贸n, an谩lisis de riesgos, desarrollo, evaluaci贸n.
    
- Gran 茅nfasis en la **gesti贸n de riesgos**.
    

**Ventajas:**

- Excelente para proyectos grandes y cr铆ticos.
    
- Control continuo de riesgos.
    
- Fomenta la mejora progresiva.
    

**Inconvenientes:**

- Complejo de gestionar.
    
- Costoso si el an谩lisis de riesgos no se aprovecha bien.
    

**Cu谩ndo se usa:**  
Proyectos grandes, costosos, innovadores o con alto nivel de incertidumbre.
![[modelo_espiral.png]]

#### CASE o herramientas de apoyo

**CASE (Computer Aided Software Engineering)** hace referencia al conjunto de **herramientas y metodolog铆as asistidas por ordenador** que apoyan y automatizan, total o parcialmente, las diferentes fases del ciclo de vida del software.

Aplicaciones o entornos que facilitan el desarrollo de software, proporcionando soporte desde la **an谩lisis y dise帽o**, hasta la **implementaci贸n, pruebas, documentaci贸n y mantenimiento**.

- **Objetivos principales:**
    
    - Mejorar la **productividad** de los equipos de desarrollo.
        
    - Aumentar la **calidad** del software generado.
        
    - Reducir **costes** y **tiempos** en el proceso de desarrollo.
        
    - Garantizar una mejor **documentaci贸n** y trazabilidad del proyecto.
        
- **Tipos de herramientas CASE:**
    
    - **Upper CASE**: apoyan fases iniciales (an谩lisis, modelado, dise帽o). Ej: herramientas UML, modeladores de BD.
        
    - **Lower CASE**: enfocadas en fases posteriores (codificaci贸n, pruebas, mantenimiento). Ej: generadores de c贸digo, depuradores.
        
    - **Integrated CASE (I-CASE)**: cubren pr谩cticamente todo el ciclo de vida.
        
- **Funciones comunes:**
    
    - Modelado de procesos y datos (diagramas UML, ER).
        
    - Generaci贸n autom谩tica de c贸digo y documentaci贸n.
        
    - Gesti贸n de versiones y configuraci贸n.
        
    - Pruebas autom谩ticas.
        
    - Control de proyectos y m茅tricas.
        
- **Ventajas:**
    
    - Consistencia entre dise帽o y c贸digo.
        
    - Facilita el trabajo en equipo.
        
    - Mejora la mantenibilidad y portabilidad del software.